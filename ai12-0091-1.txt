!standard A.5.1 (5)                                  14-02-03    AI12-0091-1/04
!class Amendment 13-10-31
!status No Action (5-0-2) 15-10-18
!status Hold (8-0-0) 14-10-19
!status work item 13-10-31
!status received 13-10-17
!priority Low
!difficulty Easy
!subject Add procedure Sin_Cos to Ada.Numerics.Generic_Elementary_Functions
!summary

Procedure Sin_Cos is added to Ada.Numerics.Generic_Elementary_Functions

!problem

In many cases you need the sinus and the cosinus of an angle.
Modern FPUs (at least since 80387 in 1987) provide the calculation of both
sin and cos at the same time (fsincos instruction). In performance-sensitive
programs, calling the Sin and Cos functions separately is an obvious bottleneck.

!proposal

(See summary.)

!wording

Add after A.5.1(5):

procedure Sin_Cos (X        : in Float_Type'Base; Sin, Cos : out Float_Type'Base);

procedure Sin_Cos (X, Cycle : in Float_Type'Base; Sin, Cos : out Float_Type'Base);

Modify A.5.1(10):

The [functions]{subprograms} have their usual mathematical meanings. When the
Base parameter is specified, the Log function computes the logarithm to the
given base; otherwise, it computes the natural logarithm. When the Cycle
parameter is specified, the parameter X of the forward trigonometric
[functions]{subprograms} (Sin, Cos, Tan,[ and] Cot{, and Sin_Cos}) and the
results of the inverse trigonometric functions (Arcsin, Arccos, Arctan, and
Arccot) are measured in units such that a full cycle of revolution has the given
value; otherwise, they are measured in radians.

Modify A.5.1(38):

When the parameter X has the value zero, the Sqrt, Sin, Arcsin, Tan, Sinh,
Arcsinh, Tanh, and Arctanh functions yield a result of zero, {the Sin parameter
of the Sin_Cos procedure yields a value of zero,}[and] the Exp, Cos, and Cosh
functions yield a result of one{, and the Cos parameter of the Sin_Cos procedure
yields a value of one}.

Modify A.5.1(41):

The results of the Sin, Cos, Tan,[ and] Cot{, and Sin_Cos}
[functions]{subprograms} with specified cycle are exact when the mathematical
result is zero; those of [the first two]{Sin, Cos, and Sin_Cos} are also exact
when the mathematical result is ñ 1.0.

Modify A.5.1(45):

A prescribed zero result delivered at the origin by one of the odd functions
(Sin, Arcsin, Sinh, Arcsinh, Tan, Arctan{,} or Arccot as a function of Y when X is
fixed and positive, Tanh, and Arctanh){, or the Sin parameter of procedure
Sin_Cos,} has the sign of the parameter X (Y, in the case of Arctan or Arccot).

Add after G.1.2(4):

procedure Sin_Cos (X : in Complex; Sin, Cos : out Complex);

Modify G.1.2 (36):

When the parameter X has the value zero, the Sqrt, Sin, Arcsin, Tan, Arctan,
Sinh, Arcsinh, Tanh, and Arctanh functions yield a result of zero; {the Sin
parameter of the Sin_Cos procedure yields a value of zero; }the Exp, Cos, and
Cosh functions yield a result of one; {and the Cos parameter of the Sin_Cos
procedure yields a value of one; }the Arccos and Arccot functions yield a real
result; and the Arccoth function yields an imaginary result.

Modify G.1.2 (48):

The implementation of the Exp function of a complex parameter X is allowed to
raise the exception Constraint_Error, signaling overflow, when the real
component of X exceeds an unspecified threshold that is approximately
log(Complex_Types.Real'Safe_Last). This permission recognizes the impracticality
of avoiding overflow in the marginal case that the exponential of the real
component of X exceeds the safe range of Complex_Types.Real but both components
of the final result do not. Similarly, the Sin[ and]{,} Cos{, and Sin_Cos }(resp.,
Sinh and Cosh) [function]{subprograms} are allowed to raise the exception
Constraint_Error, signaling overflow, when the absolute value of the imaginary
(resp., real) component of the parameter X exceeds an unspecified threshold that
is approximately log(Complex_Types.Real'Safe_Last) + log(2.0). This permission
recognizes the impracticality of avoiding overflow in the marginal case that the
hyperbolic sine or cosine of the imaginary (resp., real) component of X exceeds
the safe range of Complex_Types.Real but both components of the final result do
not.

Modify G.2.4 (6):

2.0 · EF.Float_Type'Model_Epsilon, in the case of the Sqrt, Sin,[ and] Cos{,
and Sin_Cos} [functions]{subprograms};

Modify G.2.4 (16):

The absolute value of the result of the Sin, Cos, and Tanh functions{, and the
Sin and Cos parameters of the Sin_Cos procedure,} never exceeds one.

!discussion

Besides taking advantage of hardware often offering a single sincos
instruction, adding a Sin_Cos procedure would also allow sharing of the
argument range reduction.

On the other hand, some objections have been raised to adding a Sin_Cos
procedure on the grounds that it should be left to the compiler’s optimizer
rather than the programmer having to do anything special.  After all, we
don’t have a Quot_Rem procedure to handle the likely case of the Quotient
and Remainder being generated by a single divide instruction.

A similar sincos function appears in some C family implementations, e.g. GNU C
(from 1999), Visual Studio C++ (from 2013), HLSL (the High Level Shading
Language for Windows DirectX), Linux, OpenCL (a C derivative for parallelism),
and Cg (a C derivative for graphics programming).  It does not seem to appear
in the C 11 or C++ 11 standards though.

!ASIS

No ASIS impact.

!ACATS test

An ACATS C-Test is needed.

!appendix

!topic Ada.Numerics.Generic_Elementary_Functions: procedure Sin_Cos
!reference A.5.1 (5)
!from Gautier de Montmollin 17-10-13
!keywords sin cos sin_cos
!discussion

Here is a proposal for an addition to the trigonometric part of elementary functions:


   procedure Sin_Cos (X : in Float_Type'Base; Sin, Cos : out Float_Type'Base);

The rationale is the following: in many cases you need the sinus and the
cosinus of an angle. Modern FPUs (at least since 80387 in 1987) provide the
calculation of both sin and cos at the same time (fsincos instruction).
In performance-sensitive programs, calling the Sin and Cos functions
separately is an obvious bottleneck.

****************************************************************

From: Jeff Cousins
Sent: Tuesday, December 24, 2013  9:32 AM

Here's my go at some words.  I've included cycle and complex versions too; they
can always be cut if not wanted. [This is version /02 of the AI - Editor.]

AI12-0091 was the only AI from the meeting to catch the attention of the UK Ada
panel, with people saying that they didn't like it, it should be up to the
compiler to perform any optimisation.  So despite my having done this work I
might feel that I have to vote against it, or at least abstain.  Oh what irony.

By the way, there's a new book out on Ada Lovelace, by James Essinger.  If
you're quick, you might manage a  last minute request to Santa.

****************************************************************

From: Robert Dewar
Sent: Thursday, December 26, 2013  2:53 PM

> AI12-0091 was the only AI from the meeting to catch the attention of
> the UK Ada panel, with people saying that they didn't like it, it
> should be up to the compiler to perform any optimisation.  So despite
> my having done this work I might feel that I have to vote against it,
> or at least abstain.  Oh what irony.

Can you be more specific about their objections? I really don't see anything
objectionable in this AI!

****************************************************************

From: Jeff Cousins
Sent: Friday, December 27, 2013  10:44 AM

I've not got the precise words with me, I'll check when I get back to work.  I
think they could live with it.

****************************************************************

From: Tucker Taft
Sent: Friday, December 27, 2013  2:24 PM

> Here's my go at some words.  I've included cycle and complex versions too;
> they can always be cut if not wanted...

My only objection, from a cursory reading, is that you refer to it as "SinCos"
in the text but "Sin_Cos" in the Ada source code.

****************************************************************

From: Jeff Cousins
Sent: Saturday, December 28, 2013  5:47 PM

Sorry, I'd intended no underscore as the sincos from various Unixs, glibc and
the latest Visual Studio don't have one, unless people think that SinCos doesn't
look very Ada-like and would prefer Sin_Cos (or Sincos).

****************************************************************

From: Tucker Taft
Sent: Thursday, January 2, 2014  1:45 PM

"CamelCase" is never used in the Ada reference manual, so I would recommend
using "Sin_Cos" consistently throughout.

****************************************************************

From: Robert Dewar
Sent: Thursday, January 2, 2014  2:10 PM

I also prefer Sin_Cos

I DoNotLike camel case :-)

****************************************************************

From: Jeff Cousins
Sent: Thursday, January 2, 2014  2:52 PM

So here is take 2: [This is version /03 of the AI - Editor.]

****************************************************************

From: Tucker Taft
Sent: Thursday, January 2, 2014  8:24 PM

We generally follow the rule that in a list of N >= 3 items, there are N-1
commas (that is, there is a comma before the final "or" or "and").  You violated
this in a few circumstances.  It looks like the original wording might have
violated it occasionally as well...

****************************************************************

From: Robert Dewar
Sent: Thursday, January 2, 2014  8:49 PM

Yes, this is a standard style rule (this is called the "Oxford" comma). Here is
a well known example:

  I'd like to thank my parents, Sinead O'Connor and the Pope

  I'd like to thank my parents, Sinead O'Connor, and the Pope

These sentences have rather different meanings :-) :-)

****************************************************************

From: Randy Brukardt
Sent: Thursday, January 2, 2014  8:53 PM

> We generally follow the rule that in a list of N >= 3 items, there are
> N-1 commas (that is, there is a comma before the final "or" or "and").
> You violated this in a few circumstances.  It looks like the original
> wording might have violated it occasionally as well...

That wasn't the most helpful comment: the first 5 or so items that I saw are all
correct, including most of the inserts. It would be better to point out the
exact places that you mean, because *everybody* leaves those out sometimes. (And
it's unnatural for our UK members, so that's more likely with them.) He missed
one in A.5.1(41), and there was an existing one missed in A.5.1(45). I didn't
see any others, but I didn't look very hard.

Three additional comments:

Technical: You probably would need to make some updates in G.2.4, accuracy
requirements for elementary functions, because the section mentions Sin and Cos
and anything that applies to them ought to also apply to Sin_Cos.

Editorial: Don't bother with the Corrigendum wording sections, because those
have to be created in our unique markup -- writing them in formatted HTML does
no good whatsoever. It just makes the document larger and makes it look at lot
more complex than it is.

General: The !discussion of the original AI claims that no wording changes would
be needed. Obviously, you have a pile of them, so we need a new !discussion
section. Perhaps some of the text from the minutes about the objections to the
idea and the reasons that we should do this anyway would be valuable. The note
you sent me this afternoon that neither the C nor C++ standards (but some
popular implementations of C++ do) have this routine is also useful information.

****************************************************************

From: Robert Dewar
Sent: Thursday, January 2, 2014  9:05 PM

> And it's unnatural for our UK members

Outrage! An American claiming that the British find the Oxford comma unnatural.
You are obviously not familiar with the twitter storm raging currently on this
issue :-)

****************************************************************

From: Geert Bosch
Sent: Sunday, January 5, 2014  9:52 PM

> AI12-0091 was the only AI from the meeting to catch the attention of the UK
> Ada panel, with people saying that they didn't like it, it should be up to the
> compiler to perform any optimisation.  So despite my having done this work I
> might feel that I have to vote against it, or at least abstain.  Oh what
> irony.

I have to say that I'm not unsympathetic to this view.  In strict mode, argument
reduction has to be accurate (can't use a simple machine approximation of Pi),
as the final result has to have a relative error of at most 2 epsilon. So, there
only seems to be an efficiency argument, which is indeed not a very good reason
to add a new function, especially as many compilers already recognize and
optimize the occurrence of Sin (X) and Cos (X) with identical arguments.

Furthermore, I note that C11 standard does not provide a sincos function. Of
course, on the flip side, implementation is trivial. Still, I think programs
would generally be more readable when using Sin and Cos functions versus a
Sin_Cos function. Moreover, the irregularity of this being a procedure rather
than a function bothers me a bit.

****************************************************************

From: Jeff Cousins
Sent: Monday, February 3, 2014  5:42 AM

Another go at AI12-0091 [This is version /04 of the AI.]

****************************************************************

From: Tucker Taft
Sent: Tuesday, February 4, 2014  11:31 PM

Looks good.  But as you point out in the discussion, it is not clear whether
this is a good idea or not, but if we decide it is a good idea, this seems like
good wording for it.

****************************************************************

From: Jeff Cousins
Sent: Wednesday, February 5, 2014  3:15 AM

Thanks Tuck, well put.

****************************************************************

From: Gautier de Montmollin
Sent: Thursday, March 27, 2014  4:32 AM

Just my comment on this topic (following the discussion in AI12-0091-1).
 
Acually, a smart compiler can optimise close enough calls to Sin(E) and Cos(E),
E being any expression, by using the Common Subexpression Elimination
technique. But... it would require detecting the special case of Sin and Cos
being from the same instanciation of Ada.Numerics.Generic_Elementary_Functions,
then call a Sin_Cos procedure. If Sin_Cos is finally not added to
Ada.Numerics.Generic_Elementary_Functions, this procedure would be in a package
hidden to the programmer.
 
Of course both can co-exist: Sin_Cos officially added to
Ada.Numerics.Generic_Elementary_Functions _and_ the above optimisation - the
latter would allow Ada <= 2012 code to benefit from the speedup, the former
would ensure the fast variant is used even on a compiler not providing this
optimisation.

****************************************************************

