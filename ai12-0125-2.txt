!standard 5.2.1(0)                                 15-10-08  AI12-0125-2/01
!class Amendment 15-10-08
!status work item 15-10-08
!status received 15-09-22
!priority Low
!difficulty Easy
!subject Add +=, -=, *=, ...

!summary

Define +=, -=, *=, ... in terms of "+" operator, "-" operator, etc.

!problem

Incrementing, decrementing, scaling, etc., are all somewhat painful in
Ada, particularly if the object being updated has a long name, or
involves any sort of dynamic addressing:

   My_Package.My_Array(I).Field := My_Package.My_Array(I).Field + 1;

Some sort of short-hand would be welcome, as it would ease both
readability and writability, while reducing the possibility of error,
such as unintended multiple evaluations of expressions in the name, or
mismatching array indices.

!proposal

We propose to define new *update* operations, "+=", "-=", "*=", "and=", "or=",
etc. as short hands for assigning a new value of the left hand side to
be the corresponding operator applied between itself and the right hand
side.

In this proposal there is no way to explicitly define these operations
-- they are effectively defined implicitly in terms of the corresponding
operator, whenever such an operator is defined and directly visible, and
has a result type that is the same as that of its left-hand operand.

We could envision a separate AI that would allow such operations to be
declared explicitly to override the default implementation, perhaps
using a declaration such as:

   procedure "+="(Left : in out T; Right : T);
   
The operation "/=" represents somewhat of a challenge.  We would propose
to allow it, being disambiguated by its use in an assignment context
versus in an expression context.

!wording

Add a new subclause:

        5.2.1 Update Operations

        An update_statement assigns a value to a variable computed by
        applying a binary operator combining its old value and the value
        of an expression.  This *underlying* binary operator is the
        operator identified by the lexical element formed by omitting
        the trailing '=' from the update_operation lexical element.

           update_statement ::=
             /variable_/name update_operation expression;
           update_operation ::= += | -= | *= | /= | **= | &= |
                                mod= | rem= | and= | or= | xor=
                        
          Name Resolution Rules

        An update_statement is equivalent to a local renaming of the
        /variable_/name to a unique temporary name, followed by an
        assignment_statement with the /variable_/name being this
        temporary name, and with the expression being a call on a
        function denoted by the underlying operator symbol, with the
        first operand being the temporary name and the second operand
        being the expression of the update_statement.

NOTE: Some change will also be needed in 2.2 Lexical Elements, ... if we
decide to proceed further with this AI.

!examples
  
X += 1;  --  Equivalent to X := X + 1;

A(I) *= 2;  --  Equivalent to:
--  declare
--     Temp : <type of A(I)> renames A(I);
--  begin
--     Temp := Temp * 2;
--  end;

!discussion

The update_statement is defined strictly by equivalence to a local
rename followed by an assignment statement with the right-hand side
being a call on a function denoted by an operator symbol.  All
visibility and name resolution rules should follow from that.  This is
analogous to RM 6.6(2), which through equivalence determines all the
rules of visibility and name resolution for operators.

As indicated in the proposal, we can envision a separate AI which
permits explicit declaration of update operations such as "+=", but that
seems of lower priority.

We have chosen to defer proposing wording changes to "2.2 Lexical
Elements, ..." as these seem less critical to the evaluation of this
proposal.

!ASIS

** TBD **

!ACATS Tests

ACATS B and C-Tests would be needed.

!appendix

From: Tucker Taft
Sent: Tuesday, September 22, 2015  1:32 PM

Here is an alternative version of AI12-0125, introducing the notion of an
"Update_Statement" defined by equivalence to a longer-hand rename followed
by an assignment. [This is AI12-0125-2/01 - Editor.]

****************************************************************

From: Bob Duff
Sent: Tuesday, September 22, 2015  3:47 PM

> Define +=, -=, *=, ... in terms of "+" operator, "-" operator, etc.

Seems like a good idea.  But shouldn't it be "+:=", etc?

> The operation "/=" represents somewhat of a challenge.

"/:=" ?

> As indicated in the proposal, we can envision a separate AI which 
> permits explicit declaration of update operations such as "+=", but 
> that seems of lower priority.

Negative priority, I'd say.  ;-)  Why would you want that?
It just seems to add confusion to programs, and complexity to the language.

****************************************************************

From: Gary Dismukes
Sent: Tuesday, September 22, 2015  4:03 PM

> > Define +=, -=, *=, ... in terms of "+" operator, "-" operator, etc.
> 
> Seems like a good idea.  But shouldn't it be "+:=", etc?

That's what some preferred the last time this was discussed (Robert
definitely felt that way, see AI05-0187).  I tend to agree.

...
> Negative priority, I'd say.  ;-)  Why would you want that?
> It just seems to add confusion to programs, and complexity to the 
> language.

Agreed.

****************************************************************

From: Jean-Pierre Rosen
Sent: Tuesday, September 22, 2015  4:04 PM

> Here is an alternative version of AI12-0125, introducing the notion of 
> an "Update_Statement" defined by equivalence to a longer-hand rename 
> followed by an assignment.

I would qualify this as "low cost, low benefit". But maybe good PR, and PR is
what Ada needs...

****************************************************************

From: Tucker Taft
Sent: Tuesday, September 22, 2015  4:12 PM

>> Define +=, -=, *=, ... in terms of "+" operator, "-" operator, etc.
>
> Seems like a good idea.  But shouldn't it be "+:=", etc?

We discussed this in the ARG, but I believe the majority preferred the simpler
syntax.  It also makes things easier for users coming from other languages.
It is a "short hand" after all... ;-)

>> ... As indicated in the proposal, we can envision a separate AI which 
>> permits explicit declaration of update operations such as "+=", but 
>> that seems of lower priority.
>
> Negative priority, I'd say.  ;-)  Why would you want that?

Because the update operation could be significantly more efficient when dealing
with types like sets, matrices, etc., by avoiding the storage allocation,
copying, etc.

> It just seems to add confusion to programs, and complexity to the 
> language.

Not sure why you say that.  We allow people to override the default
implementation of "=" even though the compiler will build one for you
automatically out of a component-by-component equality.

****************************************************************

From: Bob Duff
Sent: Tuesday, September 22, 2015  6:41 PM

> We discussed this in the ARG, but I believe the majority preferred the 
> simpler syntax.

You mean they preferred the "less readable" syntax.  ;-)

Try the vote again at an ARG meeting when I'm there, and see if it comes out
differently.  Anyway, I suppose I can live with "+=".

>...It
> also makes things easier for users coming from other languages.  It is a
> "short hand" after all... ;-)

I don't have much sympathy for the "coming from other languages"
argument.  That's what got us "X, Y: array(...;" and then you can't say "X := Y;".

> >> ... As indicated in the proposal, we can envision a separate AI 
> >> which permits explicit declaration of update operations such as 
> >> "+=", but that seems of lower priority.
> >
> > Negative priority, I'd say.  ;-)  Why would you want that?
> 
> Because the update operation could be significantly more efficient 
> when dealing with types like sets, matrices, etc., by avoiding the storage
> allocation, copying, etc.

Good point.  I suppose that's why C++ allows it.

But I'm not a big fan of user-defined operators on "sets, matrices, etc",
primarily because the notations we allow don't match the maths notations.
"<=" does NOT mean Is_Subset!

So I doubt I'd use "+=" on anything but integers.  (And I'm not sure I'd EVER
use "xor=" etc.  I'd be OK with just "+=" and "-=". Or better, "+:=" and
"-:=".)

> > It just seems to add confusion to programs, and complexity to the 
> > language.
> 
> Not sure why you say that.  We allow people to override the default
> implementation of "=" even though the compiler will build one for you
> automatically out of a component-by-component equality.

I think your analogy is inapt.  It is sometimes useful for "=" to mean
something other than the default.  It is never useful for "+=" mean something
other than "+" combined with ":=".  (Correct me if I'm wrong!) If I'm right,
then the ONLY reason to have user-defined "+=" is for efficiency.

****************************************************************

From: Tucker Taft
Sent: Tuesday, September 22, 2015  9:24 PM

> Or better, "+:=" and "-:="...

      and /:= and *:=

I will say that most of the versions including ':' look like emoticons to
me ... ;-)

****************************************************************

From: Jean-Pierre Rosen
Sent: Wednesday, September 23, 2015  3:03 AM

>> It just seems to add confusion to programs, and complexity to the 
>> language.
> 
> Not sure why you say that.  We allow people to override the default 
> implementation of "=" even though the compiler will build one for you 
> automatically out of a component-by-component equality.

But here, it involves assignment. We do not allow to redefine ":=", and for
good reasons after a language study note that lead to controlled type. How
would such a redefinition interact with Adjust?

I smell the ugly stench of a can of worms...

****************************************************************

From: Arnaud Charlet
Sent: Wednesday, September 23, 2015  3:21 AM

I agree with Jean-Pierre. If we allow users redefining += then we should also
allow the redefinition of :=

I also prefer += over +:= if we do introduce this new operator FWIW.

****************************************************************

From: Tucker Taft
Sent: Wednesday, September 23, 2015  7:29 AM

> ... But I'm not a big fan of user-defined operators on "sets, 
> matrices, etc", primarily because the notations we allow don't match 
> the maths notations.  "<=" does NOT mean Is_Subset! ...

I am confused by this.  Why can't you use "<=" for Is_Subset? and "<" for
"Is_Proper_Subset"?  That is what I did in the last "Set" package I built...

Also, Ada already uses "+", "-", "*", etc. for Matrix/Vector operations
(G.3.1), and "-", "and", "or", and "xor" for Set operations (A.18.9).

There were some issues with "implies" for boolean, but I believe the new
"(if A then B)" is a reasonable replacement for "implies".

****************************************************************

From: John Barnes
Sent: Wednesday, September 23, 2015  7:47 AM

I would leave this whole wretched topic severly alone; we have discussed it
all before. It just makes Ada bigger and more confusing.

****************************************************************

From: Tucker Taft
Sent: Wednesday, September 23, 2015  8:24 AM

I guess I don't agree. This short-hand is very straightforward, and is present
in almost all other languages in wide use today. I do a fair amount of
programming in other languages, and I find having to write
"Amazing_Long_Name := Amazingly_Long_Name + 1;" one of the most tedious things
about Ada relative to other languages. And I don't see it aiding readability
in Ada. Rather, it merely increases the "noise" without adding anything to
the "signal."

****************************************************************

From: Arnaud Charlet
Sent: Wednesday, September 23, 2015  8:24 AM

I agree with Tuck. It won't make the language more confusing IMO, it will make
it more usable and as long as we do not enter the "redefine assignment
operators" can of worm, the change looks pretty straightforward.

I don't buy the argument "it just makes Ada bigger" since this argument would then apply to any new proposed feature.

****************************************************************

From: Bob Duff
Sent: Wednesday, September 23, 2015  8:16 AM

> > ... But I'm not a big fan of user-defined operators on "sets, 
> > matrices, etc", primarily because the notations we allow don't match 
> > the maths notations.  "<=" does NOT mean Is_Subset! ...
> 
> I am confused by this.  Why can't you use "<=" for Is_Subset? and "<" 
> for "Is_Proper_Subset"?

Because "<" in maths means "less than".  It does not mean "is proper subset".
 It's bad enough that ASCII doesn't have a proper "<="
character, but "<=" is as close as we can get to "less or equal"
-- it certainly shouldn't be used to mean "is subset".
(Unicode has subset operators, but I don't know how to type them, and Ada
doesn't allow them as operators.)

>...That is what I did in the last "Set" package I built...
> 
> Also, Ada already uses "+", "-", "*", etc. for Matrix/Vector 
> operations (G.3.1),

Yuck.

>...and "-",
> "and", "or", and "xor" for Set operations (A.18.9).

Those aren't so bad, because they make some sense mathematically (the
intersection is those elements that are in this set AND in that set).

> There were some issues with "implies" for boolean, but I believe the 
> new "(if A then B)" is a reasonable replacement for "implies".

Yes, I think the if-expression is better than "implies".

****************************************************************

From: Tucker Taft
Sent: Wednesday, September 23, 2015  8:48 AM

> Because "<" in maths means "less than".  It does not mean "is proper 
> subset".  ...

The symbol "<=" is used more generally than that within a partial ordering.
Here is Wikipedia's entry on "partial order":

A (non-strict) partial order[2] is a binary relation "<=" over a set P which
is reflexive, antisymmetric, and transitive, i.e., which satisfies for all a,
b, and c in P:

a <= a (reflexivity);
if a <= b and b <= a then a = b (antisymmetry); if a <= b and b <= c then
a <= c (transitivity).
In other words, a partial order is an antisymmetric preorder.

... Standard examples of posets arising in mathematics include:

...
The set of subsets of a given set (its power set) ordered by inclusion (see the
figure on top-right). Similarly, the set of sequences ordered by subsequence,
and the set of strings ordered by substring. ...

****************************************************************

From: Jean-Pierre Rosen
Sent: Wednesday, September 23, 2015  9:00 AM

> I find having to write "Amazing_Long_Name := Amazingly_Long_Name + 1;"
> one of the most tedious things about Ada

I don't buy this one. Use GPS, type three characters and then Ctrl-/ (automatic
completion).

The only good reason is avoiding to evaluate names twice in the case of
complicated subcomponents, possibly involving functions with side-effect.

****************************************************************

From: Tucker Taft
Sent: Wednesday, September 23, 2015  11:38 AM

I think you underestimate the difficulty of encouraging programmers who are
potential new users, to adopt Ada, presuming they are familiar with other
languages. This sort of tedium turns them off.  Yes if you are an expert these
things become less of a burden, but for people considering the language, these
sorts of things just make the language feel heavy and painful to use.  And
using Ctrl-/ or whatever doesn't address the fact that the resulting unhelpful
verbosity makes the program more tedious to read as well.

****************************************************************

From: John Barnes
Sent: Thursday, September 24, 2015  7:58 AM

We used to have the view (maybe just Jean) that programs were read many more
times than they were written. And read by different people. So it was a good
idea that they should all write the same way. Hence a bad idea to give too
much choice.

But I take the point about encouraging those who have been damaged by terser
languages. Maybe we need a tool that turns a program into "standard form" 
(we would argue about that for ever I suppose). And maybe a restriction No
Terseness.

Anyway, I am going on vacation now and will see what sort of an outcome has
emerged some time later.

****************************************************************

From: Tucker Taft
Sent: Wednesday, September 23, 2015  11:55 AM

>> Because the update operation could be significantly more efficient 
>> when dealing with types like sets, matrices, etc., by avoiding the storage
>> allocation, copying, etc.
>
> Good point.  I suppose that's why C++ allows it. ...

An alternative to the somewhat foreign idea of:

   procedure "+="(Left : in out T; Right : T);

might be to simply define an aspect on an operator declaration that specifies
what procedure to use when the operator appears in an update_assignment
context. E.g.:

   function "*"(Left : Matrix; Right : Scalar) return Matrix
     with Update_Operation => Scale_Matrix;

where Scale_Matrix is declared as:

   procedure Scale_Matrix(Left : in out Matrix; Right : Scalar);

This would eliminate any issues of visibility or name resolution for the update
operation at the point of use of the operator in an update_assignment, and
instead only require visibility of Scale_Matrix at the place where the aspect
specification is resolved.

This might emphasize that this is for efficiency, not for introducing some subtly
different meaning in the update_assignment context.

****************************************************************

From: Erhard Ploedereder
Sent: Thursday, September 24, 2015  9:38 AM

Can't we stick to the simple model that such operators compose but are not
overloadable, much like /= composes from "not" and "=", but is not overloadable
per se? (Yes, I know that the composing is not quite the case, but it makes it
comprehensible to think about it that way.)

Incidently: "/=" is an argument for me why these operators should include the
":". I.e., "/:=", not "/=". Or else I really do not know whether "/=" stands
for not equal or for "divide this value by ..." and PLEASE, do not rely on
overload resolution to find out the answer!

****************************************************************
