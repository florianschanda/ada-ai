!standard A.20(0)                                15-09-07    AI12-0015-1/01
!class Amendment 11-12-21
!status work item 11-12-21
!status received 11-10-13
!priority Low
!difficulty Medium
!subject Ada unit information

!summary

**TBD.

!proposal

There ought to be some standard way of retrieving compilation unit information.

AI95-0282-1 suggests that the most appropriate way of doing this is with
attributes of some sort. AI95-0282-1 was discussed at the February 2002 and
October 2003 ARG meetings. Highlights of that discussion: The IBM/Rational compiler
does not have line number information to report because of their incremental
compilation technology; they use "source position" for debugging. It is suggested
that the information be in terms of the enclosing call rather than the position of
the attribute usage. A design similar to Exception_Information is suggested.
Finally, the AI was killed because it was not deemed important enough.

!wording

Create a new subclause Annex C.8 containing:


C.8 Source Info

This subclause describes functions that can be used to obtain the name of the
current source file, current line number, enclosing entity (current subprogram,
package, task, entry or protected subprogram), date of compilation and time of
compilation.

C.8.1 The Package Source_Info


Static Semantics

The following labguage-defined library package exists:

package Ada.Source_Info is


  function File return String with
     Import, Convention => Intrinsic;


   function Line return Positive with
     Import, Convention => Intrinsic;


   function Source_Location return String with
     Import, Convention => Intrinsic;


   function Enclosing_Entity return String with
     Import, Convention => Intrinsic;


   function Compilation_Date return String with
     Import, Convention => Intrinsic;


   function Compilation_Time return String with
     Import, Convention => Intrinsic;


end Ada.Source_Info;


The function File returns the name of the current file, not including the path
information.  The result is considered to be a static string constant.

The function Line returns the current input line number. The result is
considered to be a static expression.

The function Source_Location returns a string literal of the form "name:line",
where name is the current source file name without path information, and line is
the current line number. In the event that instantiations are involved,
additional suffixes of the same form are appended after the separating string "
instantiated at ". The result is considered to be a static string constant.

The function Enclosing_Entity returns the name of the current subprogram,
package, task, entry or protected subprogram. The string is in exactly the form
used for the declaration of the entity (casing and encoding conventions), and is
considered to be a static string constant. The name is fully qualified using
periods where possible (this is not always possible, notably in the case of
entities appearing in unnamed block statements.) Note: if this function is used
at the outer level of a generic package, the string returned will be the name of
the instance, not the generic package itself. This is useful in identifying and
logging information from within generic templates.

The function Compilation_Date returns the date of compilation. The result is
considered to be a static string constant.  The format of the string is
implementation-defined.

The function Compilation_Time returns the time of compilation. The result is
considered to be a static string constant.  The format of the string is
implementation-defined.

!Discussion

I've suggested a new section Annex C.8 as it is obtaining info known to "the
system", similar to C.7 for task info.  Any other ideas welcome.

The words are shamelessly cribbed from GNAT, with some detail made
implementation defined where I thought it was too GNAT-specific.  Maybe the
detailed format of all the strings should be implementation-defined.

For my projects, Enclosing_Entity is important for the elaboration of our
middleware.  Source_Location is useful for fault reporting.  The other functions
I've just included for compatibility with GNAT.


!ACATS test

** TBD.

!appendix

From: Gregory D Moncreaff
Sent: Thursday, October 13, 2011  6:59 PM

Is there any standard way of retrieving compilation unit information via some
mechanism in the Ada standard packages?

In C/C++ compilers, there are common standard or vendor predefined macros:
__FILE__, __LINE__ __function__ etc.

It is often useful to have programs report (for developers) the package,
routine, etc were something of interest occurred.

With Ada, generics add complexity, as you often desire to know which
instantiation of the generic encountered that interesting something.

I noticed GNAT.Source_Information. Is there any likelihood that anything similar
might become part of some future Ada standard?

****************************************************************

From: Randy Brukardt
Sent: Thursday, October 13, 2011  8:57 PM

[BTW, what's the deal with the giant ugly green text?]

> Is there any standard way of retrieving compilation unit information
> via some mechanism in the Ada standard packages?

No. This was discussed in the past, the context of Ada 2005, and it was rejected
for reasons that I no longer remember. This was recorded in AI95-00282-1 (look
it up on the Ada-auth.org site, and if you want more information, I'd suggest
looking in the meeting minutes for that AI number).

I vaguely remember difficulties defining precisely what the functions are
expected to return, in cases like inlining and generic instantiation, because
different implementations do these things differently. If we just allowed
implementations to do what they want in those cases, any such information would
be much less useful. (Imagine not knowing whether you would get information from
a generic body or an instance of that body -- very different things.)

Anyway, I think we would need to see stronger use-cases than just "some other
language provides X", especially as we've already considered this once
unsuccessfully. (Whether we'd reconsider also would depend on whether there were
genuine technical difficulties with the old proposal or it was judged not
important enough.)

****************************************************************

From: Jean-Pierre Rosen
Sent: Tuesday, October 6, 2015  2:07 AM

> Create a new subclause Annex C.8 containing: [He's refering to version /01
of the AI - Editor.]

I suggest adding:

 function Compiler_Version return String with
     Import, Convention => Intrinsic;

The function Compiler_Version returns an implementation-defined string that
identifies the compiler version. The result is considered to be a static
expression.

(I am surprised that this is not provided by Gnat. It is certainly important for
tool makers, as well as for users who have baselined compilers and want to be
able to rebuild an exact same executable)

****************************************************************

From: Randy Brukardt
Sent: Tuesday, October 6, 2015  6:29 PM

>  The function Line returns the current input line number. The result is
> considered to be a static expression.

How is this expected to work for a compiler like the old Rational one that does
not keep line numbers? (See the old discussion of AI05-0282-1.)

What happens if the line number is outside of Positive (that could happen on
Janus/Ada, as Integer is 16-bits for compatibility with older Janus/Ada
versions)?

"Considered a static expression" is not an Ada capability, and I would be very
adverse to adding it in an ad-hoc manner.

>	The function Enclosing_Entity returns the name of the current
>subprogram, package, task, entry or protected subprogram. The string is
>in exactly the form used for the declaration of the entity (casing and
>encoding conventions), and is considered to be a static string
>constant. The name is fully qualified using periods where possible
>(this is not always possible, notably in the case of entities appearing
>in unnamed block statements.)
>	Note: if this function is used at the outer level of a generic package,
> the string returned will be the name of the instance, not the generic package
> itself. This is useful in identifying and logging information from within
> generic templates.

This needs a lot more explanation, especially for the generic case. That most
certainly is not a "note"!!

How could the expected meaning work in a shared generic? Do you really mean to
incur distributed overhead for all generics just in case someone might use this
function in a generic body???

--------------------

When we discussed AI05-0282-1 (the last time we considered this idea), the GNAT
"magic package" approach was considered a bad idea. We instead considered
attributes of compilation units or something on the line of Ada.Exceptions. I'm
not sure what has changed (other than the membership and jobs of the ARG).

****************************************************************
