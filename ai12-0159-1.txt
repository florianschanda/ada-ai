!standard 3.5.9(6)                                     15-03-23  AI05-0159-1/01
!standard xx.xx(xx/x)
!class binding interpretation 15-03-23
!status work item 15-03-23
!status received 15-02-26
!priority Low
!difficulty Easy
!qualifier Omission
!subject Corrections from the Corrigendum Editorial Review
!summary

Various issues with normative wording found during editorial reviews are
addressed.

!question

(1) There does not appear to be any resolution rule that applies to a
digits_constraint. Should there be one? (Yes.)

(2) In 7.3.2(10/4) and 7.3.2(22.1/4), are the commas in the right place? (No.)

(3) There is a missing "the" in 7.3.2(21/4). Should it be added? (Yes.)

!recommendation

(See Summary.)

!wording

[Note: Remove the name of the reviewer once this is finished and approved.]

(1)

Add after 3.5.9(6): [Brukardt]

The simple_expression of a digits_constraint is expected to be of any integer
type.

(2)

Modify 7.3.2(10/4): [Moore]

After successful explicit initialization of the completion of a deferred
constant with a part of type T, if the completion is inside the immediate scope
of the full view of T[,] and the deferred constant is visible outside the
immediate scope of T, the check is performed on the part(s) of type T;

Modify 7.3.2(22.1/4): [Dismukes]

For an invariant check on a value of type T1 based on a class-wide
invariant expression inherited from an ancestor type T, any operations
within the invariant expression that were resolved as primitive
operations of the (notional) formal derived type NT[,] are{,} in the
evaluation of the invariant expression for the check on T1{,} bound to
the corresponding operations of type T1.

[Editor's note: 6.1.1(38/4) has similar text; if we move the commas in this
paragraph, we need to do it in that one as well.]

(3)

Modified 7.3.2(21/4): [Moore]

If performing checks is required by the Type_Invariant or Type_Invariant'Class
assertion policies (see 11.4.2) in effect at the point of {the} corresponding
aspect specification applicable to a given type, then the respective invariant
expression is considered enabled.

[Editor's note: Sadly, this word is missing from the unchanged part of the
paragraph. It was a last-minute change in Ada 2012 that presumably didn't get
reviewed enough. Thus this trivial change appears here.]


!discussion

(1) This appears to be an oversight.

(2) Comma madness. :-)

(3) Helps to edit. ;-)


!corrigendum 3.5.9(6)

@dinsa
For a type defined by a @fa<fixed_point_definition>, the @i<delta> of the type
is specified by the value of the @fa<expression> given after the reserved word
@b<delta>; this @fa<expression> is expected to be of any real type. For a type
defined by a @fa<decimal_fixed_point_definition> (a @i<decimal> fixed point
type), the number of significant decimal digits for its first subtype (the
@i<digits> of the first subtype) is specified by the @fa<expression> given
after the reserved word @b<digits>; this @fa<expression> is expected to be of
any integer type.
@dinst
The @fa<simple_expression> of a @fa<digits_constraint> is expected to be of
any integer type.

!ASIS

No ASIS effect.

!ACATS test


!appendix

From: Randy Brukardt
Sent: Thursday, February 26, 2015  11:15 PM

I was wondering why I didn't need to fix up a resolution rule for
digits_constraint. That turns out to be easy: there isn't any rule to fix up!

3.5.9 has resolution rules for Decimal_Fixed_Point_Definition and
Ordinary_Fixed_Point_Definition, and requires staticness of all of these
(including digits_constraint). But no resolution rule for the expression of the
digits_constraint.

This must be highly important, because its been true since the initial version
of Ada 95. :-)

One can sort of infer a resolution rule from 3.5.9(6) and from 3.5.7(4)
[depending upon whether it is a float or decimal constraint], and of course
there's Ada 83 (which treats types and subtypes the same). But it sure seems odd
that we have a complete definition of delta_constraint in J.3, including
resolution, and definitions of the resolution of all of the kinds of type
definitions, yet we never mention resolution of digits_constraint in 3.5.9 or
anywhere else.

Adding "The simple_expression of a digits_constraint is expected to be of any
integer type." to 3.5.9(6) would seem to be indicated.

****************************************************************

From: Bob Duff
Sent: Friday, February 27, 2015  9:46 AM

> This must be highly important, because its been true since the initial
> version of Ada 95. :-)

Yeah, well for me this one falls into the category "waste of time".
We all have better things to do than polishing the RM for years on end.

****************************************************************

From: Randy Brukardt
Sent: Friday, February 27, 2015  3:52 PM

We could put it into the AI of "things we don't intend to fix".

The AI of "things we don't intend to fix" contains cases where wording seems
messy, and thus there is a significant chance of introducing bugs. I don't see
how that applies here: "The simple_expression of a digits_constraint is expected
to be of any integer type." is completely straighforward.

I agree we shouldn't go looking for such things, but it's hard to justify
ignoring them when found, especially when the amount of work is essentially the
same either way. (I'd have to write up the issue and explain why we don't want
to fix it; it'd be a lot easier to just do so.) In most such cases, we're
talking about something muddled, as opposed to outright missing, which is not as
clear-cut; it's likely to be more dangerous to change.

The only question in my mind is whether 3.5.7(4) could be read to make the
needed definition. The sentence doesn't mention what syntax it applies to, so
one could argue that it is intended to apply to any expression that immediately
follows "digits" in the syntax. But I don't buy that; the syntax in question
isn't in this clause (which implies a long-distance effect that we typically
avoid), and the value after digits is never referred to as "requested decimal
precision" in 3.5.9 (where the syntax actually is), 3.5.9 specifically defines
the resolution of the value after digits for a decimal_fixed_point_definition
(which seems to put the lie to the idea that this was intended to apply to all
expressions that follow "digits"), and indeed, the constraint doesn't even have
to be used on a floating point value (so it seems odd to be using float-specific
terminology with it).

I've now probably spent 4 times as much time on this as it would have taken to
just write up a trivial AI to insert the line. Demonstrates that not only are
some things too simple that they're a waste of time to fix, but that's it's
possible for them to be so simple that it's a waste of time to complain about
them being a waste of time. :-)

****************************************************************

From: Robert Dewar
Sent: Friday, February 27, 2015  4:00 PM

> I agree we shouldn't go looking for such things, but it's hard to
> justify ignoring them when found, especially when the amount of work
> is essentially the same either way.

We could have the good taste just to ignore trivial matters without wasting time
on them :-)

****************************************************************

From: Bob Duff
Sent: Friday, February 27, 2015  4:20 PM

> I've now probably spent 4 times as much time on this as it would have
> taken to just write up a trivial AI to insert the line. Demonstrates
> that not only are some things too simple that they're a waste of time
> to fix, but that's it's possible for them to be so simple that it's a
> waste of time to complain about them being a waste of time. :-)

I suggest you don't bring such issues up in the first place.  Then nobody will
waste time.

Save it for cases where some compiler writer is genuinely confused, or where
compilers disagree, and other useful cases.

****************************************************************

From: Randy Brukardt
Sent: Friday, February 27, 2015  5:53 PM

So you want me to ignore anything I find in RM when working on the ACATS or when
editing, because there's a 0% chance of me knowing anything about the above in
those cases? (I'm neither acting as a compiler writer nor running multiple
compilers in those roles [discounting Janus/Ada for this purpose, since it's
rare that it provides useful information on the margins].) I can only find
problems where the intent as I understand it doesn't match the actual wording,
or as in this case, where there appears to be no wording at all. Trying to guess
whether a bug is going to be "significant" to someone is not really practical.

In general, people report far too few "trivial" things, meaning that they never
get fixed. That's not even solely a software problem, you see that in retail and
government and lots of other things as well. No one can fix things that they
don't know about!

Thus, I think pretty much everything should be *reported*, and leave it to our
"triage" system to decide what is important enough to put on the ARG agenda.

In this particular case, the bug is relatively horrible, in that the *type* of
an entire Ada construct is never defined. That's of course mitigated by the fact
that one can infer that it's supposed to work like other similar features, and
of course by the fact that the specific feature is hardly ever used. It's these
latter facts that give it a low priority, not the nature of the bug.

Given that in this case the bug can be fixed by adding a single sentence, the
sentence is similar to existing sentences, the sentence is specific to the
feature in question so it can't cause any conflicts, and because fixing these
things isn't done in a vacuum, but rather bundled with lots of other fixes (i.e.
a Corrigendum) so the incremental cost is low, I sent it as a stand-alone report
with the intent of writing a quickie AI to apply the fix.

If the fix would have been more complex, I still would have sent a report, but
would have suggested putting it into the "things we don't intend to fix" AI or
just filing it into an AC. But never reporting problems means that future
maintainers don't have the opportunity to fix things that we didn't, because no
one can fix anything they don't know about. (That would be especially important
should the standard get a complete overhaul, something I hope never happens. But
I don't want to make it harder for future maintainers, either.)

I don't want to be the sole arbiter of whether something needs fixing, and I
surely don't want any other single individual making that call, either. And
griping about what happens to be discovered really doesn't help, either.

If you would like to propose some alternative process for dealing with reports
like this one that does not involve sweeping them under the rug, please go
ahead. It would be useful to have some lightweight way to deal with stuff of
this sort (that's more than presentation, but obvious as to the fix). But I'm
not at all on board with ignoring genuine bugs in the Standard (or anything, for
that matter); there's a vast difference between "low priority" and "no
priority".

P.S. Now I'm up to 7 times as much time because I have to defend fixing actual
bugs in the Standard. Grumble.

****************************************************************

From: Robert Dewar
Sent: Saturday, February 28, 2015  6:22 AM

And you are wasting time because this defense is misguided IMO

****************************************************************

From: Robert Dewar
Sent: Saturday, February 28, 2015  6:24 AM

Here's the deal Randy, the RM is full of errors about things that don't matter.
Fixing one of them has no practical impact whatsoever. If you notice some small
error where the intent is obvious and there is no real problem, you should
ignore it.

It would be nice to have a goal of a 100% error free RM, but that's
unobtainable, so any action that has as part of its rationale achieving this is
flawed, at least with respect to this rationale.

****************************************************************

From: Robert Dewar
Sent: Saturday, February 28, 2015  6:26 AM

One way of handling absolutely trivial matters such as this where the fix is (a)
unimportant to anyone and (b) trivial, is to just do the fix, the same way you
would fix a spelling error.

****************************************************************

From: Randy Brukardt
Sent: Saturday, February 28, 2015  7:07 PM

Sigh. That's what I intended to do, of course. A spelling error in ancient text
(not new text) would go into a presentation AI with lots of similar fixes and
eventually the ARG votes on it when we're going to produce a document or it is
getting unwieldy (usually only takes a couple of minutes). I've done the same
with "trivial" fixes as well, although it happens that what I think is trivial
doesn't always turn out to be universal.

****************************************************************

From: Jeff Cousins
Sent: Monday, March 2, 2015  5:49 AM

> I don't want to be the sole arbiter of whether something needs fixing, and I
> surely don't want any other single individual making that call, either.

I think Randy was correct to raise this, for the reason he gave, though quietly
writing up a trivial AI to insert the line might have avoided another long
e-mail chain.  (Please don't continue it!)

****************************************************************
