!standard 6.1.1(1/3)                                 12-12-01    AI12-0045-1/01
!class binding interpretation 12-12-01
!status work item 12-12-01
!status received 12-09-19
!priority Medium
!difficulty Medium
!subject Pre- and Postconditions are allowed on generic subprograms
!summary

Aspects Pre and Post can be specified for on generic subprograms,
but not on instances of generic subprograms.

!question

6.1.1(1/3) says:
   For a subprogram or entry, the following language-defined aspects
   may be specified with an aspect_specification

  and AARM 6.1(20.a/3) adds
    ... a generic subprogram is not a subprogram.

Therefore, that pre/post-condition aspect specifications are not allowed for
generic subprograms. Should they be? (Yes.)

!recommendation

(See summary.)

!wording

Replace 6.1.1(1/3) with:

   For a subprogram other than the instance of a generic subprogram,
   a generic subprogram, or entry, the following language-defined aspects
   may be specified with an aspect_specification:


!discussion

If we allowed Pre and Post on instances that are subprograms, we
would be introducing a maintenance problem, as converting the
subprogram a package would require the removal of the aspects
(there is no corresponding feature for subprograms declared
inside of package instances). The examples of such usage have not
been compelling (they usually are refinements of overly general
aspects on the generic).

In addition, if we allowed these aspects on both the generic (which
is important) and on the instance, we'd have to define how these
combine. That is a problem for preconditions, which should combine
with "and" or "or" depending on who you are talking to (and sometimes
the topic). ["or" is required to follow LSP.] To avoid answering this
question, we make the programmer answer it explicitly. That principle
should be continued.

We considered allowing the aspects on an instance if none are given on
the generic unit in order to avoid this problem. But we decided against
this because of the maintenance problem mentioned above.

!ACATS test

ACATS tests should be created to test these rules.

!appendix

From: Steve Baird
Sent: Wednesday, September 19, 2012  1:07 PM

6.1.1(1/3) says:
   For a subprogram or entry, the following language-defined aspects
   may be specified with an aspect_specification

  and annotation 6.1(20.a/3) adds
    ... a generic subprogram is not a subprogram.

I conclude that pre/post-condition aspect specifications are not allowed for
generic subprograms.

Was this intended?  Should such aspect specifications be allowed?
IMO, they should be allowed.

****************************************************************

From: Robert Dewar
Sent: Wednesday, September 19, 2012  1:27 PM

Yes, of course they should be allowed, this is a typical case of the RM tripping
over the trap it set for everyone in considering that a generic subprogram is
not a subprogram (TERRIBLE choice!)

****************************************************************

From: Steve Baird
Sent: Wednesday, September 19, 2012  2:04 PM

As I said earlier, I think pre/post-conditions for generic subprograms hould be
allowed.

This would, however, require defining the interactions between
pre/post-conditions for a generic subprogram and for an instance thereof.

Bob Duff said (in some non-ARG mail):
> If it's allowed, and pre/post are given on both generic and instance,
> then it seems pretty obvious that both should apply.
> I think the usual rule for multiple pre/post is that the RM doesn't
> define any particular order, and allows but does not require short
> circuiting.

I agree that this is how the language should work, but I think explicit RM
wording would be needed to address this.

****************************************************************

From: Randy Brukardt
Sent: Saturday, September 22, 2012  6:45 PM

I would not have expected them to be allowed on instances. To be discussed when
I get home.

****************************************************************

From: Robert Dewar
Sent: Saturday, September 22, 2012  10:38 PM

Pre and post-conditions on instances are very useful, it would be bad to lose
them (very often the pre and post conditions can be tighted up when you have a
specific instantiation.

****************************************************************

From: Tucker Taft
Sent: Saturday, September 22, 2012  10:54 PM

Examples, please!

****************************************************************

From: John Barnes
Sent: Monday, September 24, 2012  2:11 AM

Spark allows them on both generics and instatiations.

****************************************************************

From: Robert Dewar
Sent: Monday, September 24, 2012  5:48 AM

Are there some nice usage examples from the SPARK world?

****************************************************************

From: Yannick Moy
Sent: Monday, September 24, 2012  6:03 AM

Here is the very simple example used in the document "SPARK Generics: a user view":

The generic is declared like that:

generic
    type T1 is range <>;
    type T2 is range <>;
    --# check T2 (T1'Last  * T1'Last)  <= T2'Last and
    --#       T2 (T1'First * T1'First) <= T2'Last and
    --#       T2 (T1'Last  * T1'Last)  >= T2'First;
    --#       T2 (T1'First * T1'First) >= T2'First;
function Square (X : in T1) return T2;
--# return R => R = T2 (X * X);

And here comes the instance, which states here a lower bound on the parameter (X
> 1), which results in a lower bound on the result (R >= 4):

type Actual_T1 is range 0 .. 10;
type Actual_T2 is range 0 .. Actual_T1'Last * Actual_T1'Last;

function My_Square
--# pre X > 1;
--# return R => R = T2 (X * X) and R >= 4; is new Square (T1 => Actual_T1, T2 => Actual_T2);

****************************************************************

From: John Barnes
Sent: Monday, September 24, 2012  7:24 AM

> Are there some nice usage examples from the SPARK world?

See my new Spark book.  Sorry, in a rush right now. Funeral, probate and Holiday
to deal with.

****************************************************************

From: Randy Brukardt
Sent: Tuesday, October  2, 2012  5:58 PM

I said while on vacation:

> I would not have expected them to be allowed on instances. To be
> discussed
when I get home.

In response to Steve's:

> As I said earlier, I think pre/post-conditions for generic subprograms
> hould be allowed.
>
> This would, however, require defining the interactions between
> pre/post-conditions for a generic subprogram and for an instance
> thereof.

> Bob Duff said (in some non-ARG mail):

> If it's allowed, and pre/post are given on both generic and instance,
> then it seems pretty obvious that both should apply.
> I think the usual rule for multiple pre/post is that the RM doesn't
> define any particular order, and allows but does not require short
> circuiting.

Actually, none of this follows at all. The model of specific preconditions is
that only one applies to any particular subprogram, and the reason for that is
that we couldn't agree on how multiple preconditions should apply. Specifically,
LSP suggests that multiple preconditions should be "or"ed; but most people
expect them to be "and"ed. Rather than trying to answer the question, we decided
only to allow one. (And we did the same for postconditions, mainly for
consistency.)

Therefore, there is no mechanism in the language to combine specific pre or
postconditions. One could be created, but it suffers from the same problems that
we were unable to solve for the language as a whole. I don't see any reason why
this is easier.

I'm assuming that class-wide pre- and post-conditions are not allowed on generic
subprograms because such subprograms cannot be primitive for any type. They can
only be allowed on instances; as such I'm only talking about specific pre- and
postconditions below. One could imagine trying to allow class-wide pre- and
post-conditions on generic subprograms, but that requires even more rule
changes.

There are a number of options for this problem:

(1) Leave the language alone (which does not allow pre- and post-conditions on
generic subprograms, but does allow them on instances). If it is truly valuable
to allow them on instances (and I admit I am skeptical), this is probably the
best option.

(2) Allow pre- and post-conditions on generic subprograms, but not on instances.
This is the rule I would have expected, as it avoids combining preconditions,
and it follows the contract model of the language. It should be clear that a
*post*condition on an instance is a dubious construct, as the postcondition puts
conditions on the body of a subprogram, and the body of a generic subprogram is
the same for all instances (the contract model makes that true). It doesn't make
much sense to put additional requirements on the body of some instance, as there
is almost no way for the implementation of the body to change. (For those of us
that use code sharing, this seems even more obvious, as the postcondition is
expected to be evaluated as part of the body, and thus it ought to be the same
for all instances. It can be implemented otherwise, but that's more work and
seems just wrong.)

If one considers a precondition a mirror image of a postcondition, one would
expect the same of preconditions. It makes more sense for the preconditions to
be different, but again the body cannot change (or take advantage of) a
different precondition.

One would hope that the Ada language is powerful enough to be able to write
pre- and post-conditions in terms of the formal parameters, so that the pre- and
post-conditions of the actual instance are more useful (and detailed) than the
conditions of the generic. If that's not the case, I'd rather strengthen the
expressions of the language (which would be useful in generic units as well)
than corrupt the contract model of the language.

It also should be noted that generic subprograms are not that common; most
generics are generic packages. For a subprogram declared in a generic package,
it is not possible to put any pre- or post-conditions on the subprogram in an
instance. I think it would be preferable (and surely more consistent) if the
language treated generic subprograms as if they are a generic package containing
a single subprogram (this is effectively how Janus/Ada implements them). It
seems weird to allow additional capabilities for generic subprograms over any
other subprogram that happens to be declared in a generic.

Moving on to other options:

(3) Allow pre- and post-conditions on *either* a generic subprogram or its
instance, but not both.

This avoids the combining problem, and gives maximum flexibility. But we still
have the problem of treating generic subprograms and subprograms declared in
generic packages differently.

Similarly,

(4) Allow pre- and post-conditions on both generic subprograms and instances
thereof, but the last declared specific pre- and post-condition is the only one
used.

This matches the rules for inheritance, but it seems likely to be confusing to
users. I think I'd prefer (3) to (4) if we're going to allow these on instances
at all.

Finally, of course

(5) Allow pre- and post-conditions on both generic subprograms and instances
thereof, and "and" them together. But, as noted above, we don't do this in any
other case in the language (for specific preconditions especially), and this
opens up a whole level of expectations that the language does not try to
accomplish. As such, I think this is a very bad idea, especially at this late
date.

P.S. Please try to have language discussions here or on Ada-Comment, and not
privately on AdaCore mailing lists that aren't on the (public) record and that
freeze out half of the ARG.

****************************************************************

From: Bob Duff
Sent: Tuesday, October  2, 2012  6:35 PM

> Actually, none of this follows at all.

Yes, I (now) think you're right.

> It also should be noted that generic subprograms are not that common;
> most generics are generic packages.

Yes, that's a good point.  Which leads to --> leave it alone.

> P.S. Please try to have language discussions here or on Ada-Comment,
> and not privately on AdaCore mailing lists that aren't on the (public)
> record and that freeze out half of the ARG.

Well, I often have language discussions with misc folks (usually, but not
necessarily AdaCore folks), of the form "Is this worth asking ARG?". It's not a
matter of freezing anybody out, just trying to avoid extra possibly-useless work
for ARG.

****************************************************************

From: Randy Brukardt
Sent: Tuesday, October  2, 2012  6:49 PM

> > It also should be noted that generic subprograms are not
> that common;
> > most generics are generic packages.
>
> Yes, that's a good point.  Which leads to --> leave it alone.

Actually, it doesn't, because that would allow preconditions on instances of
generic subprograms (but not the generic subprogram), while in a generic package
the situation is reversed.

I'd expect that to cause problems when converting a generic subprogram into a
package (or vice-versa, much less common). I know I've sometimes written generic
subprograms only to realize I needed a constant or a helper function. So I had
to convert it into a package, which is easy to do. It would be weird to have to
move the preconditions (and rewrite them as well) when doing such a change.

So I think (as I've stated before) that the best option is to allow specific
preconditions and postconditions on generic subprograms, but not to allow them
on instances.

****************************************************************

From: Randy Brukardt
Sent: Tuesday, October  2, 2012  6:55 PM

...
> > P.S. Please try to have language discussions here or on Ada-Comment,
> > and not privately on AdaCore mailing lists that aren't on the
> > (public) record and that freeze out half of the ARG.
>
> Well, I often have language discussions with misc folks (usually, but
> not necessarily AdaCore folks), of the form "Is this worth asking
> ARG?".
> It's not a matter of freezing anybody out, just trying to avoid extra
> possibly-useless work for ARG.

Yes, that's fine. In this case, however, it appeared that the "outside the ARG
discussion" happened after the thread was opened here. That's what I objected to
(although it might have been that Steve had "dipped into the archives" for the
quote from you).

As for "possibly useless work for the ARG", having noted the extremely low
balance in my checking account, I'd welcome some useless work. ;-)

****************************************************************

From: Tucker Taft
Sent: Tuesday, October  2, 2012  7:49 PM

> So I think (as I've stated before) that the best option is to allow
> specific preconditions and postconditions on generic subprograms, but
> not to allow them on instances.

Wouldn't that be incompatible with the (almost) published standard?
Allowing them on generics or instances but not both would be compatible, and
plenty flexible, and avoid the various issues about combining.

****************************************************************

From: Robert Dewar
Sent: Tuesday, October  2, 2012  8:28 PM

> So I think (as I've stated before) that the best option is to allow
> specific preconditions and postconditions on generic subprograms, but
> not to allow them on instances.

I strongly disagree, allow them both places! I see no reason for a narrower
viewpoint.

****************************************************************

From: Robert Dewar
Sent: Tuesday, October  2, 2012  8:31 PM

> (5) Allow pre- and post-conditions on both generic subprograms and
> instances thereof, and "and" them together. But, as noted above, we
> don't do this in any other case in the language (for specific
> preconditions especially), and this opens up a whole level of
> expectations that the language does not try to accomplish. As such, I
> think this is a very bad idea, especially at this late date.

I think this is the obvious choice and for me (1)-(4) are all non-starters.
Certainly in GNAT we will allow the pre/post pragmas in both places anyway (we
also allow multiple pragmas to appear).

I find the objection Randy raises unconvincing

****************************************************************

From: Tucker Taft
Sent: Tuesday, October  2, 2012  8:35 PM

> I strongly disagree, allow them both places! I see no reason for a
> narrower viewpoint.

I agree in allowing them on either place, but allowing them on both for a given
subprogram seems unnecessary.  In the few cases where that is absolutely
critical, a wrapper is always possible.

****************************************************************

From: Steve Baird
Sent: Wednesday, October  3, 2012  2:37 PM

> I agree in allowing them on either place, but allowing them on both
> for a given subprogram seems unnecessary.

This rule is similar in spirit to the existing 13.1.1(14/3) "don't specify the
same aspect twice" rule. Looks good to me.

> In the few oases where that is absolutely critical, a wrapper is
> always possible.

I think it is unlikely that anyone will complain anytime soon that introducing a
wrapper means that they can't pass it to a generic which takes a formal
instance.

****************************************************************

[Editor's note: There are 47 more messages on this topic (and a few
that are off-topic) that remain to be filed.]

****************************************************************
