!standard A(3/4)                                    16-11-23  AI12-0200-1/03
!standard 13.11.4(21/3)
!standard 13.11.4(31/3)
!class binding interpretation 16-08-11
!status Amendment 1-2012 16-11-09
!status ARG Approved 9-0-1  16-10-08
!status work item 16-08-11
!status received 16-06-12
!priority Low
!difficulty Easy
!qualifier Clarification
!subject Improve reentrancy requirements for language-defined subprograms
!summary

Clarify that the reentrancy requirements for language-defined subprograms
apply to any two language-defined subprograms with overlapping parameters.

!question

The wording in A(3/4) doesn't clearly state two (obvious?) requirements:

     1) The requirement applies to calls to any pair of such subprograms,
        not just to two calls to the same subprogram.
     2) The requirement applies in the case where the overlapping occurs
        between parameters of two different calls, not between two
        parameters of one call.

Should this be clarified? (Yes.)

!recommendation

(See Summary.)

!wording

Replace A(3/4) by:

     The implementation shall ensure that each language-defined
     subprogram is reentrant in the sense that concurrent calls on any
     two (possibly the same) language-defined subprograms perform as
     specified, so long as all pairs of objects (one from each call)
     that are either denoted by parameters that could be passed
     by reference, or are designated by parameters of an access type, are
     nonoverlapping.

!discussion

Point (1) was in fact one of the purposes of AI12-0052-1, changing the wording
to "any language-defined subprogram" rather than "the same subprogram".

!corrigendum A(3/4)

@drepl
The implementation shall ensure that each language-defined subprogram
is reentrant in the sense that concurrent calls on any language-defined
subprogram perform as specified, so long as all objects that are denoted by
parameters that could be passed by reference or designated by parameters of
an access type are nonoverlapping.
@dby
The implementation shall ensure that each language-defined subprogram
is reentrant in the sense that concurrent calls on any two (possibly the same)
language-defined subprograms perform as specified, so long as all pairs of
objects (one from each call) that are either denoted by parameters that could
be passed by reference, or are designated by parameters of an access type, are
nonoverlapping.

!ASIS

No ASIS effect.

!ACATS test

The absence of race conditions isn't directly testable; tests can depend on
this property which may indirectly test for correct implementation.

!appendix

From: Randy Brukardt
Sent: Tuesday, November 22, 2016  6:05 PM

In his review of the minutes (aside: should be posted soon), Jeff notes that the
AI12-0200-1 "doesn't flow". The approved wording is:

The implementation shall ensure that each language-defined subprogram is
reentrant in the sense that concurrent calls on any two (possibly the same)
language-defined subprograms perform as specified, so long as all pairs of
objects (one from each call) that {either} are denoted by parameters that could
be passed by reference{,} or designated by parameters of an access type are
nonoverlapping.

---

The problem here is that the "are nonoverlapping" applies to both kinds of
parameters; the inserted comma tends to make it read as if that only applies to
the second part. Jeff suggested adding an "are" and another comma, thus:

The implementation shall ensure that each language-defined subprogram is
reentrant in the sense that concurrent calls on any two (possibly the same)
language-defined subprograms perform as specified, so long as all pairs of
objects (one from each call) that {either} are denoted by parameters that could
be passed by reference{,} or {are} designated by parameters of an access type{,}
are nonoverlapping.

But I don't think that helps; now "are nonoverlapping" is completely hanging in
space.

The usual fix for such dangling items is to pull them to the front part:

The implementation shall ensure that each language-defined subprogram is
reentrant in the sense that concurrent calls on any two (possibly the same)
language-defined subprograms perform as specified, so long as all pairs of
objects (one from each call) {are nonoverlapping} that {either} are denoted by
parameters that could be passed by reference{,} or {are} designated by
parameters of an access type[ are nonoverlapping].

The "that" doesn't make much sense here, perhaps "if" would be better:

The implementation shall ensure that each language-defined subprogram is
reentrant in the sense that concurrent calls on any two (possibly the same)
language-defined subprograms perform as specified, so long as all pairs of
objects (one from each call) {are nonoverlapping if either} [that] are denoted
by parameters that could be passed by reference{,} or {are} designated by
parameters of an access type[ are nonoverlapping].

But this doesn't seem to have the right meaning (it seems to say that it applies
if either parameter meets these requirements, the  rule applies, while we want
it to apply only if both parameters meet the requirements.

I'm out of ideas at this point. Any better suggestions???

****************************************************************

From: Jeff Cousins
Sent: Wednesday, November 23, 2016  4:32 AM

> The implementation shall ensure that each language-defined subprogram is
> reentrant in the sense that concurrent calls on any two (possibly the same)
> language-defined subprograms perform as specified, so long as all pairs of
> objects (one from each call) {are nonoverlapping if either} [that] are denoted
> by parameters that could be passed by reference{,} or {are} designated by
> parameters of an access type[ are nonoverlapping].

> But this doesn't seem to have the right meaning (it seems to say that it
> applies if either parameter meets these requirements, the  rule applies, while
> we want it to apply only if both parameters meet the requirements.

> I'm out of ideas at this point. Any better suggestions???

It's getting rather long for a single sentence, but here's another attempt:

The implementation shall ensure that each language-defined subprogram is
reentrant in the sense that concurrent calls on any two (possibly the same)
language-defined subprograms perform as specified, so long as all pairs of
objects (one from each call) {are nonoverlapping if both objects of such a pair
are either} [that are] denoted by {a }parameter[s] that could be passed by
reference or designated by {a }parameter[s] of an access type[ are
nonoverlapping].

****************************************************************

From: John Barnes
Sent: Wednesday, November 23, 2016  5:42 AM

I don't think that putting "are overlapping" earlier helps at all.

I think that Jeff's suggestion is not bad. However, I suggest reversing "either"
and "are" so we end up with:

The implementation shall ensure that each language-defined subprogram is
reentrant in the sense that concurrent calls on any two (possibly the same)
language-defined subprograms perform as specified, so long as all pairs of
objects (one from each call) that are either denoted by parameters that could be
passed by reference, or are designated by parameters of an access type, are
nonoverlapping.

I find it helps to remove square and curly brackets so that the result is
clearer and then when satisified to put them back for the record.

****************************************************************

From: Tullio Vardanega
Sent: Wednesday, November 23, 2016  7:17 AM

I like this version, both for formulation and absense of brackets.

****************************************************************

From: Tucker Taft
Sent: Wednesday, November 23, 2016  3:06 PM

Johns version works for me.  Next approach would probably be bullets, but John's
seems good enough without them.

****************************************************************

From: Randy Brukardt
Sent: Wednesday, November 23, 2016  8:20 PM

I prefer Jeff's (Wednesday) suggestion to Jeff's (Monday) suggestion as modified
by John. But it appears that I'm outnumbered, so I'll shut up (at least until we
have someone who can't understand it - that may be a while, since Adam isn't
around anymore).

****************************************************************
