!standard 5.4(4/3)                                  16-01-09  AI12-0214-1/01
!class Amendment 17-01-09
!status work item 17-01-09
!status received 16-10-08
!priority Very_Low
!difficulty Hard
!subject Case pattern matching
!summary

** TBD.

!problem

Ada has case statements and expressions, that allows testing for the value of a
variable. It allows and enforce full coverage checking. On the other hand, it
only works on discrete types, which limits their usefulness somehow.

Also, Ada has discriminated types with variant parts, that allows
having a variable "shape" for a record type depending on the value of a
discriminant. This is a very useful facility, but we have no way of ensuring
that a user is accessing the correct components, and we have to resort to
dynamic checks.


   type Maybe (Option : Boolean) is record
      case Option is
         when True => Val : Integer;
         when False => null;
      end case;
   end record;

   procedure Print_The_Maybe (M : Maybe) is
   begin
      if M.Option = False then
         Put_Line (M.Val'Img);  --  Error here, not statically checked
      else
         null;
      end if;
   end Print_The_Maybe;

!proposal

We propose introducing a new construct, mainly in case statements and
expressions's alternatives: Pattern matching of the value being discriminated
upon.

We would use aggregate syntax to specify the structure and expected values of
the value matched upon, like in the following example:

	type R is record
		A, B : Boolean;
	end record;

	R_Inst : R;

	case R_Inst is
		when (True, True) => ..
		when (True, False) => ..
		when (False, False) => ..
		when (False, True) => .. -- Every possibility has been covered.
	end case;

Along with this proposal, we propose relaxing the legality checking of the type
of the top level value being matched upon by the case expression and statement,
from discrete types, to the following rule:

The top level value's type needs to have a finite and known number of shapes.
With shape being defined as:

- For numeric types, the shape is the number of possible values the type.
- For record types, the shapes are the set of possible components lists
  (1 for regular records, N for variant records)
- For array types with known bounds there is one shape.
- For array types, there is is as many shapes as there are possible
  (Start_Index, End_Index) combinations.
- For private types there is no known shape.

The box can be used when the users just wants to ignore a value, and others can
be used in aggregate to denote of every other component, like in regular
aggregates, and with the same limitations.

    type Arr is array (Natural range <>) of Integer;

    A : Arr := ...;

    case A is
        -- Match when first element is one
        when (1, others => <>) => ...

        -- Match when every element except first is one
        when (<>, others => 1) => ...
    end case;

But the proposal is not yet complete. In the example above, we want to be able
to, not only match on the value of the Option discriminant, but also to easily
get the value of the Val field, when Option is True. For this, we want to
introduce a new variable binding that will be bound to Val. In terms of
coverage, it is also equivalent to a wildcard (any value for Val will trigger
the match):

	procedure Print_The_Maybe (M : Maybe) is
	begin
	   case M is
	      declare V : Integer when (True, V) => Put_Line (V'Img);
	      when (Option => False) => null;
	   end case;
	end Print_The_Maybe;

Since there can be no ambiguity on the type of V in the above example, we
propose making the type annotation optional, and allow the following:

	procedure Print_The_Maybe (M : Maybe) is
	begin
	   case M is
	      declare V when (True, V) => Put_Line (V'Img);
	      when (Option => False) => null;
	   end case;
	end Print_The_Maybe;

The great benefit of the above is that with this construct, it is impossible to
access the value of Val when the Option discriminant is false: An incorrect
aggregate structure will result in an error.

This in turn allows more expressive ways of designing APIs when you need to
return several values. So far you had the following options:

	--  Example 1
	procedure Read (Success : out Boolean; Number : out Integer);

	--  Usage:
	declare
		Success : Boolean;
		Number  : Integer;
	begin
		Read (Success, Number);
		Put_Line (Number'Image);
	end;
	--  A lot of boiler plate just to read and print a number. Also user can
	--  ignore error case !


	--  Example 2
	function Read (Number : out Integer) return Boolean;

	--  Usage:
	declare
		Number  : Integer;
		Success : Boolean := Read (Number);
	begin
		Put_Line (if Success then Number'Image else "No number");
	end;
	--  A lot of boiler plate still

	--  Example 3
    type Read_Result (Success : Boolean) is record
        case Success is
        when True =>  Result  : Integer;
        when False => null;
        end case;
    end record;

	function Read return Read_Result;

	--  Usage:
	declare
		Read_Res : Read_Result := Read;
	begin
		Put_Line (if Read_Res.Success
		          then Read_Res.Result'Image else "No number");
	end;

With pattern matching, taking the third example's API, you can express the use
case as:

	Put_Line (case Read is
			  declare Result when (True, Result) => Result'Image,
			  when (Success => False) => "No_Number");

You don't need to introduce a procedural context to treat the result of the
read, and the user has to handle the failure case, as opposed as the previous
examples.

This pattern of being able to encourage the user to handle error cases, and
remind him to treat everything via coverage checking, is very useful in contexts
where exceptions are not an option.

The rule on types shapes means that the user cannot match on a value of a Float
type, but can match on a record containing a Float. For subcomponents of a type
with no known number of shapes, the only allowed matchers are either a reference
to a pattern object declaration or a box:

    type Rec (Option : Boolean) is record
        Value : Float;
    end record;

    R : Rec;

    case R is
        when (True, 1.0) => ...          --  Illegal
        when (True, <>) => ...           --  Legal
        declare A when (True, A) => ...  --  Legal
    end case;

This feature allows matching on string literals, which are considered like
array aggregates:

      case S is
          when "begin" => ...;
          when "end" => ...;
          when others => ...;
      end case;

Syntax

This proposal requires introducing a new branch in the
case_statement_alternative and case_expression_alternative rules.

	pattern_object_declaration ::=
	    defining_identifier [":" (subtype_indication
	                              | access_definition
	                              | array_type_definition)]

	pattern_object_declarations ::=
	    pattern_object_declaration {"," pattern_object_declaration}

	case_statement_alternative ::=
	    "declare" pattern_object_declarations
    	    "when" discrete_choice_list => sequence_of_statements
	    | "when" discrete_choice_list "=>" sequence_of_statements

    case_expression_alternative ::=
	    "declare" pattern_object_declarations
    	    "when" discrete_choice_list => dependent_expression
    	| "when" discrete_choice_list "=>" dependent_expression

Name Resolution Rules

A pattern matching literal should have the valid structure of a literal for
the value matched. His type is the type of the value matched, without ambiguities.

In the case of aggregate literals, the type of each subcomponent's value is the
type of the expected subcomponent, as in a regular aggregate.

In the case of aggregate literals with values bound through pattern object
declarations, their type is the type of the subcomponent in the type definition.

Even though the type of a component cannot be ambiguous, the user is allowed to
annotate the type of the pattern object declaration, for clarity purposes and
for consistency with other object declarations. In that case, the type
annotation needs to refer exactly to the type of the component.

In order to allow matching on records containing accesses, if the matched value
or sub-component is an access, then a literal of the type pointed to by the
access type is allowed. This would allow use of the form:

    type Linked_List_Node;
    type Linked_List is access all Linked_List_Node;

    type Linked_List_Node is record
       Val  : Integer;
       Next : Linked_List;
    end record;

    L : Linked_List;

    case L.all is
       declare First, Second, Third, Next
       when (First, (Second, (Third, Next))) => ...
       when others => ...
    end case;

Legality Rules

The only entities allowed in a pattern matching literal are other literals and
statically known constants. Referencing a non constant declaration defined in
an outer scope is illegal.

Declared pattern objects are constant views of the components they refer to.
Modifying their value is illegal. Taking a non-constant access on them is
illegal.

The coverage check rule is relaxed in the following way:

1. A pattern object is considered to cover every possible value of the matched
   value, regardless whether the type of the value is discrete or not.
2. The set represented by the union of all possible case alternatives needs to
   cover every possible value of the type being matched upon.
3. The only option for the user to cover every possible value of a type with a
   conceptually infinite number of values is to use a pattern object, a box, or
   a top level "others =>" alternative
4. The box and pattern objects won't trigger overlap errors for already covered
   values, so that the following is possible

   case A is
        when (1, True) => ...
        declare A when (1, A) => ...
   end case;

5. Every match via a literal for a specific value must precede a match for this
   specific value made via a box or via a pattern object.

    type Rec is record
        A, V : Integer range 1 .. 3;
    end record;

    R : Rec;

    case R is
        when (1, <>) =>  ...

        -- Illegal! Should be before the matching of V subcomponent via box
        when (1, 1) =>  ...
    end case;

The type of the value being matched upon needs to have a known number of shapes,
following the definition of shape outlined in the proposal.

Dynamic semantics

The pattern matching literal will be structurally and recursively compared to
the value matched against. In case of a pattern object, any value is accepted.
The match will succeed if every literal or constant matched is equal to its
counterpart in the dynamic value matched upon.

!wording

** TBD (some of the above could be used)

!discussion

Coverage check

From preliminary discussions, I expect one of the biggest objections to this
proposal to be the lifting of the restriction of the case statement and
expression to work only on values of discrete types.

Lifting it is fundamental to this proposal. There was however a number of
different possibilities:

1. Restrict to types that directly or indirectly have a discrete number of
   possible values. A record containg integer sub-components would be allowed,
   but not a record containing a floating point sub-component.
2. Restrict to types that have a limited number of shapes. Dont allow direct
   matching on literals for types that are not discrete. That's the choice
   being made currently.
3. Allow everything, just enforce the "others" when there is no discrete number
   of possible values.

It is felt that 2 is the most pragmatic choice. it's necessary in order to make
pattern-matching useful enough, because the first alternative would disable
useful use cases such as this one:

    type Read_Result (Success : Boolean) is record
        case Success is
        when True =>  Result  : Integer;
        when False => null;
        end case;
    end record;

	function Read return Read_Result;

	case Read is
	    declare Result when (True, Result) => ...
	    when others => ...
	end case;

Ranges, subtypes:

When matching discrete types, one can use ranges and subtypes to match a set of
value of the discrete type. Question is, should we allow matching sub-components
in the same way, as in:

    type Rec is record
        A, V : Integer range 1 .. 3;
    end record;

    R : Rec;

    case R is
        when (1 .. 2, 1 .. 2) =>
        when (1 .. 3, 3) =>
        when (3, 1 .. 3) =>
    end case;

Syntax

The syntax for declaring pattern objects is new so we must consider different
options.

First proposal:

   case A is
        when (1, True) => ...
        declare A when (1, A) => ... -- Declaration via declare .. when ...
   end case;

This one is pretty verbose but feels very Ada idiomatic in our opinion.

Rejected alternative:

   case A is
        when (1, True) => ...
        when (1, A) => ... -- Declaration via declare .. when ...
   end case;

This proposal corresponds to the way it is done in most languages with
pattern-matching, but we feel it is not adapted to Ada.

While sufficient, this syntax would be confusing: We don't know whether A is a
statically known constant or a newly declared pattern object without looking at
the context. Also, if A also refers to an outer scope declaration, the code
might do something else than what the user expects, if he's not familiar with
the rule that you cannot use variables in matches.

Third proposal:

   case A is
        when (1, True) => ...
        when (1, A is <>) => ... -- Declaration via identifier "is" <>
   end case;

Less verbose than the first proposal, and also has the advantage of composing
nicely with the box matching syntax. Could also accomodate optional type
annotations. Possible cons: The aggregate is cluttered, declarations are
scattered, and the alterations to the grammar would be less localized.

Alternatives order rule

The rule 5 described in legality rules might be too restrictive.

5. Every match via a literal for a specific value must precede a match for this
   specific value made via a box or via a pattern object.

This disallows the following, which intuitively corresponds to a valid execution:

   case A is
        when (1, 1) => ...
        when (1, <>) => ...
        when (<>, 1) => ...
   end case;

First option:
- Alternatives are considered in sequential order.
- If an element of an alternative is less general than the same one in a
  preceding alternative, then the subset of cases handled by this alternative
  and by none of the preceding alternatives, must be non-empty.

This would disallow the following

   case A is
       when (1, <>) => ...
       when (1, 1) => ... -- This pattern can never be matched
   end case;

But allow those:

   case A is
       when (1, <>) => ...
       when (<>, 1) => ...
   end case;

   case A is
       when (<>, 1) => ...
       when (1, <>) => ...
   end case;

In the example above, both case statements are valid, and for the value (1, 1),
a different code path will be executed, making the branches order sensitive,
which goes against the current design of the case statement.

This is the way pattern matching works in OCaml/Haskell/etc..

Second option:

- An alternative can not appear twice.
- If an element of an alternative is less general than the same one in a
  preceding alternative, then the subset of cases allowed by both alternatives
  must be covered by a preceding alternative.

In this option, we're constraining the order of the alternatives for
readability, eg. we force the user to go from less general to more general
matches, but the order of alternatives has no direct influence on the code that
will be executed in the end, making the proposal more in line with the current
case statement and expression.

   case A is  -- ILLEGAL
       when (1, <>) => ...
       when (<>, 1) => ...
   end case;

   case A is  -- ILLEGAL
       when (<>, 1) => ...
       when (1, <>) => ...
   end case;

   case A is  -- LEGAL
       when (1, 1) => ...
       when (<>, 1) => ...
       when (1, <>) => ...
   end case;

!ASIS

** TBD.

!ACATS test

Many new ACATS tests would be needed to check that the new capabilities are
supported.

!appendix

From: Raphael Amiard
Sent: Sunday, October 9, 2016  7:41 AM

Here is an AI for a feature proposal I've been drafting with some help. Of
course too late to discuss at this meeting, but it'll let a lot of time for
people to look at it until the next one though !
[This is version /01 of the AI - Editor.]

****************************************************************

From: Tucker Taft
Sent: Thursday, October 13, 2016  10:14 AM

Did you consider the syntax:

    when (True, <A>) =>

where <id> is declaring id to represent what "<>" would have represented on
its own?

I think we also talked about:

   when R : (True, <>) =>

where you now use R.blah to refer to parts matched by <>

I find the "declare ... when ..." syntax too verbose, and think the
"when R : ( ... ) =>"  syntax the most consistent with how exception
occurrences are declared now.

****************************************************************

From: Raphael Amiard
Sent: Thursday, October 13, 2016  10:29 AM

> Did you consider the syntax:
>
>    when (True, <A>) =>

No, we didn't think about that. On the one hand, I like it because it's very
concise, coherent with the unnamed case, and quite clear about what this does !

On the other hand I'm worried that it will make the lexer's work a bit harder,
since here "<A>" can be parsed either as "Op(LT), Id(A), Op(GT)" or as
"Pattern_Match_Id(A)".

I'll try and implement this in libadalang's parser, to see what the
repercussions are.

>
> where <id> is declaring id to represent what "<>" would have 
> represented on its own?
>
> I think we also talked about:
>
>   when R : (True, <>) =>
>
> where you now use R.blah to refer to parts matched by <>
>
> I find the "declare ... when ..." syntax too verbose, and think the "when R : 
> ( ... ) =>" syntax the most consistent with how exception occurrences 
> are declared now.

Yes we did. I think that being able to name the top level object is a great
capability, so I'll add it to the AI. I don't however, as explained in the
previous exchanges, think that it is a substitute for sub-component matching.
If you want I can submit my rationale on the ARG thread.

****************************************************************

From: Tucker Taft
Sent: Thursday, October 13, 2016  10:40 AM

...
> On the other hand I'm worried that it will make the lexer's work a bit 
> harder, since here "<A>" can be parsed either as "Op(LT), Id(A), Op(GT)"
> or as "Pattern_Match_Id(A)".

This one is pretty easy, because you can actually lex it as LT, Id, GT.  But
you just have to distinguish in the parser between unary "<" and binary ">"
which is pretty easy.  We make that sort of distinction all the time.

> I'll try and implement this in libadalang's parser, to see what the repercussions are.

I would be surprised if it is difficult to handle in the parser.  I don't see
any need to alter the lexer for this.

...
>> I find the "declare ... when ..." syntax too verbose, and think the 
>> "when R : ( ... ) =>" syntax the most consistent with how exception
>> occurrences are declared now.
>
> Yes we did. I think that being able to name the top level object is a 
> great capability, so I'll add it to the AI. I don't however, as 
> explained in the previous exchanges, think that it is a substitute for 
> sub-component matching. If you want I can submit my rationale on the ARG thread.

Yes, please do, as I don't remember why you think it is not an adequate substitute.

****************************************************************

From: Raphael Amiard
Sent: Thursday, October 13, 2016  10:41 AM

...
>This one is pretty easy, because you can actually lex it as LT, Id, GT.  But
>you just have to distinguish in the parser between unary "<" and binary ">"
>which is pretty easy.  We make that sort of distinction all the time. 

Yes, you're probably right !

>Yes, please do, as I don't remember why you think it is not an adequate
>substitute. 

Here it is, slightly edited to use the new syntax you proposed - I already
love it :)


Naming the object that is being matched upon, while it can be useful, is not
sufficient. First it's not as expressive. You'll have to repeat the path to the
sub (sub-sub) component you wanted to match, which is verbose and possibly
error prone. And then, if you want to make a rule out of the fact that you can
statically check that the path is correct, the implementation will be more
complex, because you'll have to remember the paths and check that what the user
is doing is going along those paths. Taking the realistically complex example
of the connection I showed earlier:

type Connection_State is (Init, Connecting, Connected, Disconnected);

type Ping (Has_Ping_Info : Boolean := False) is record
   case Has_Ping_Info is
   when True =>
      Last_Ping_Time    : Time_T;
      Last_Ping_Id      : Ping_Id;
   end case;
end record;  

type Connection_Info (State : Connection_State) is record
   Server : Internet_Address;
   case State is
   when Connected =>
      Session_Id        : Unbounded_String;
      Ping_Info         : Ping;
   when Connecting =>
      When_Initiated    : Time_T;
   when Disconnected =>
      When_Disconnected : Time_T;
   when Init =>
      null;
   end case;
end record;

C : Connection_Info;

case C is
   when (Connected, <S_Id>, (True, <>, <Ping_Time>)) =>
      Put_Line ("Connected ! Session Id is " & S_Id & " Ping time is " & Ping_Time'Image);
   when others => null;
end case;

Constrast with only top-level object naming:

case C is
   when CC : (Connected, <>, (True, <>, <>)) =>
      Put_Line ("Connected ! Session Id is "
                & CC.Session_Id & " Ping time is "
                & C.Ping_Info.Last_Ping_Time'Image);
                --  Woops, I used the original name rather than the matched
                --  name ! The compiler will silently ignore my error.
   when others => null;
end case;

Having to repeat the path is less readable and more error prone. You go through
the trouble of expressing the pattern, just to have to repeat the logic
underneath, effectively writing the paths twice, once in aggregate syntax, the
other in prefix syntax.

Statically ensuring that the accessed information is correct will be much more
work for the compiler.

Not to mention, that would be (yet another) feature that we don't implement
like other languages.

****************************************************************

From: Randy Brukardt
Sent: Monday, January 9, 2016  6:45 PM

(Replying to an old thread that I must have missed back in October:)

...	
>Constrast with only top-level object naming:
>		
>case C is
>   when CC : (Connected, <>, (True, <>, <>)) =>
>      Put_Line ("Connected ! Session Id is "
>                & CC.Session_Id & " Ping time is "
>                & C.Ping_Info.Last_Ping_Time'Image);
>                --  Woops, I used the original name rather than the matched
>                --  name ! The compiler will silently ignore my error.

What error? C and CC are views of the same object, and clearly have the same
value. If there is an error here, it is declaring CC in the first place (see
below).

>		   when others => null;
>		end case;

One would want these shorthands in cases where the name of the original object
is too complex. If, for instance, the original object was a function call with
parameters, then the shorthand makes sense:

case Get_Connection (From => Server) is
 ... -- Rest as above.

But in this case, if you mistyped the identifier, the compiler will give you
an error. So I don't see any real problem with mistakes here.

Keep in mind that every identifier (and every entity for that matter) that one
declares adds to the cognitive load of the reader. You really shouldn't do it
unless it actually helps reading the code. (Exactly where that line is
obviously is a personal choice, but it is far away from renaming a single
character identifier.)

>Having to repeat the path is less readable and more error prone. You go 
>through the trouble of expressing the pattern, just to have to repeat 
>the logic underneath, effectively writing the paths twice, once in 
>aggregate syntax, the other in prefix syntax.

Arguably, that's a good thing.

BTW, Ada doesn't currently allow positional <> aggregate components, and I'd
suggest that we retain that rule here. (Assuming you really want to model these
patterns as aggregates.) [Especially as many style guides ban positional record
aggregates altogether.] Therefore, your example would have to be written
something like:

case Get_Connection (From => Server) is
   when CC : (State => Connected, Server => <>,
              Session_Id => <>,
              Ping_Info => (Has_Ping_Info => True, Last_Ping_Time => <>, Last_Ping_Id => <>)) =>
       Put_Line ("Connected ! Session Id is "
                 & CC.Session_Id & " Ping time is "
                 & CC.Ping_Info.Last_Ping_Time'Image);

So the names you need are already in the source. Declaring more names would
just be more noise.

[Aside: in writing the above, I see that your original example doesn't have
enough components (the Server component seems to have been left out). Which is
why many style guides require component names ... ;-)]

>Statically ensuring that the accessed information is correct will be 
>much more work for the compiler.

There seems to be no need to do that. Again, this is just a different view of
an existing object, we really should not care which of those views is accessed.
		
>Not to mention, that would be (yet another) feature that we don't 
>implement like other languages.

You already know what I think about that: if you want to use some other
language, do that. Don't try to mess up Ada with the exact features of other
languages; whatever we do should fit into the Ada model and not look like it
was stolen from someone else. (That's why some form of case coverage is
mandatory for this feature.)

Tucker's idea seems to fit with the existing syntax of the language, and seems
to be sufficient for the job.

****************************************************************
